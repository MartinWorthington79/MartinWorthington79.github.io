<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Forest — Wordsearch (Single column + word list below)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root { --muted:#9aa3b2; --ink:#e5e7eb; --accent:#60a5fa; --found:#10b981; --cell:28px; --gap:4px; }
  * { box-sizing:border-box; }
  html,body { height:100%; }
  body { min-height: 100dvh; margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background: radial-gradient(1200px 800px at 20% -10%, #172554 0%, #0b0e14 60%); color: var(--ink); }

  .wrap { max-width: 960px; margin: 0 auto; padding: 16px; display:flex; flex-direction:column; gap: 14px; }
  .panel { background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08); border-radius:18px; backdrop-filter: blur(8px); overflow:hidden; }
  .header { padding:12px 14px; border-bottom: 1px solid rgba(255,255,255,.06); }
  .title { font-weight:800; font-size:18px; letter-spacing:.2px; }
  .muted { color: var(--muted); font-size:12px; }

  .content { padding:12px; }
  .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  button { background:linear-gradient(180deg,#1f2937,#111827); color:#eef2ff; border:1px solid rgba(255,255,255,.1); padding:8px 10px; border-radius:12px; cursor:pointer; font-weight:700; font-size:12px; }
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); border-radius:999px; font-size:12px; color:var(--muted); }

  /* Grid container keeps a fixed height calc so it fits without overlapping words list */
  .grid-wrap { height: calc(100dvh - 170px); /* header+toolbar+padding allowance */ min-height: 300px; max-height: 80vh; display:grid; place-items:center; overflow:hidden; }
  @media (max-width:520px){ .grid-wrap{ height: calc(100dvh - 200px);} }

  .grid { --rows:30; --cols:20; display:grid; grid-template-columns: repeat(var(--cols), var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap); user-select:none; touch-action:none; }
  .cell { width:var(--cell); height:var(--cell); line-height:var(--cell); text-align:center; border-radius:8px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.06); font-weight:700; font-size:calc(var(--cell)*.5); }
  .cell.empty { background:transparent; border-color:transparent; pointer-events:none; }
  .cell.hover { outline:2px solid var(--accent); }
  .cell.preview { background: rgba(96,165,250,.25); border-color: rgba(96,165,250,.6); }
  .cell.selected { background: rgba(34,211,238,.35); border-color: rgba(34,211,238,.8); }
  .cell.found { background: rgba(16,185,129,.35); border-color: rgba(16,185,129,.9); }

  /* Words section always visible below grid */
  .words-panel .content { display:flex; flex-direction:column; gap:8px; }
  .words { display:flex; flex-direction:column; gap:4px; }
  .word { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px; border-radius:12px; background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06); }
  .word .txt { font-weight:600; }
  .word.done .txt { text-decoration: line-through; opacity: .6; }
  .word .ok { color: var(--found); font-weight:800; }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="header">
      <div class="title">Forest</div>
      <div class="muted">Interactive word search — grid above, words below. Drag to select (straight or diagonal).</div>
    </div>
    <div class="content">
      <div class="toolbar">
        <button id="resetBtn" title="Clear all progress">Reset</button>
        <button id="revealBtn" title="Reveal a random remaining word">Reveal one</button>
        <span class="chip" id="timer">00:00</span>
        <span class="chip" id="progress">0 / 0</span>
      </div>
      <div class="grid-wrap"><div id="grid" class="grid"></div></div>
    </div>
  </div>

  <div class="panel words-panel">
    <div class="header"><div class="title">Find these</div><div class="muted">Completed words move to the bottom and get struck through.</div></div>
    <div class="content"><div id="wordsList" class="words"></div></div>
  </div>
</div>

<script>
// ====== Embedded puzzle JSON (unchanged) ======
const PUZZLE = {
  "puzzle_id": "new_20251103142318",
  "puzzle_name": "Untitled Puzzle",
  "grid": [
    "                    ",
    "        BCPZ        ",
    "      YADHCTAM      ",
    "     ITPJAEQZYH     ",
    "    HUAUDMCAKNVS    ",
    "    YFACUPRSILIE    ",
    "    EDANKSAGERVE    ",
    "   ROLYATRETEPARL   ",
    "   ELPKEILPLGMNTE   ",
    "  QHDERPDPTYDIDYAY  ",
    "  PUBICOLTRAIREKGE  ",
    "  MWIHURAOAXRARCUL  ",
    " HXKGGPUBLUXBCSIEBM ",
    " SUMHUGEIMTSTLORCMM ",
    " HYTEOLMRUSINENTUEU ",
    " ZYZALOYALTCEMIRPWP ",
    "  EPDCRSGLANREDEHJ  ",
    "     MYPFONATNZ     ",
    "         FCR        ",
    "         KOF        ",
    "         ILR        ",
    "  UVA    NLO   FXI  ",
    "  RCHKI  TYV HSABL  ",
    "  JSDERUOYMEEHZEVN  ",
    "  JUMDOAORORIZHGXJ  ",
    "  JOHNROBERTSONOPC  ",
    "  ALOLLIMMEGEIHCRA  ",
    "  Q  DNUORGYTIC  A  ",
    "       XSZXMF       ",
    "          Q         "
  ],
  "words": [
    {"text":"PETERTAYLOR","display_text":"Peter Taylor","path":[[7,13],[7,12],[7,11],[7,10],[7,9],[7,8],[7,7],[7,6],[7,5],[7,4],[7,3]]},
    {"text":"CITYGROUND","display_text":"City Ground","path":[[27,14],[27,13],[27,12],[27,11],[27,10],[27,9],[27,8],[27,7],[27,6],[27,5]]},
    {"text":"EUROPEANCUP","display_text":"European Cup","path":[[13,7],[12,7],[11,7],[10,7],[9,7],[8,7],[7,7],[6,7],[5,7],[4,7],[3,7]]},
    {"text":"GARIBALDI","display_text":"Garibaldi","path":[[16,8],[15,8],[14,8],[13,8],[12,8],[11,8],[10,8],[9,8],[8,8]]},
    {"text":"YOUREDS","display_text":"You Reds","path":[[23,9],[23,8],[23,7],[23,6],[23,5],[23,4],[23,3]]},
    {"text":"LEAGUECUP","display_text":"League Cup","path":[[7,16],[8,16],[9,16],[10,16],[11,16],[12,16],[13,16],[14,16],[15,16]]},
    {"text":"FACUP","display_text":"FA Cup","path":[[5,5],[5,6],[5,7],[5,8],[5,9]]},
    {"text":"WEMBLEY","display_text":"Wembley","path":[[15,17],[14,17],[13,17],[12,17],[11,17],[10,17],[9,17]]},
    {"text":"MIRACLEMEN","display_text":"Miracle Men","path":[[8,13],[9,13],[10,13],[11,13],[12,13],[13,13],[14,13],[15,13],[16,13],[17,13]]},
    {"text":"CLOUGHIE","display_text":"Cloughie","path":[[16,5],[15,5],[14,5],[13,5],[12,5],[11,5],[10,5],[9,5]]},
    {"text":"STANCOLLYMORE","display_text":"Stan Collymore","path":[[14,10],[15,10],[16,10],[17,10],[18,10],[19,10],[20,10],[21,10],[22,10],[23,10],[24,10],[25,10],[26,10]]},
    {"text":"STUARTPEARCE","display_text":"Stuart Pearce","path":[[14,10],[13,10],[12,10],[11,10],[10,10],[9,10],[8,10],[7,10],[6,10],[5,10],[4,10],[3,10]]},
    {"text":"JOHNROBERTSON","display_text":"John Robertson","path":[[25,2],[25,3],[25,4],[25,5],[25,6],[25,7],[25,8],[25,9],[25,10],[25,11],[25,12],[25,13],[25,14]]},
    {"text":"VIVANDERSON","display_text":"Viv Anderson","path":[[4,14],[5,14],[6,14],[7,14],[8,14],[9,14],[10,14],[11,14],[12,14],[13,14],[14,14]]},
    {"text":"TREVORFRANCIS","display_text":"Trevor Francis","path":[[25,11],[24,11],[23,11],[22,11],[21,11],[20,11],[19,11],[18,11],[17,11],[16,11],[15,11],[14,11],[13,11]]},
    {"text":"ARCHIEGEMMILL","display_text":"Archie Gemmill","path":[[26,17],[26,16],[26,15],[26,14],[26,13],[26,12],[26,11],[26,10],[26,9],[26,8],[26,7],[26,6],[26,5]]},
    {"text":"NIGELDOUGHTY","display_text":"Nigel Doughty","path":[[4,13],[5,12],[6,11],[7,10],[8,9],[9,8],[10,7],[11,6],[12,5],[13,4],[14,3],[15,2]]},
    {"text":"TRENTBRIDGE","display_text":"Trent Bridge","path":[[17,12],[16,12],[15,12],[14,12],[13,12],[12,12],[11,12],[10,12],[9,12],[8,12],[7,12]]},
    {"text":"MATCHDAY","display_text":"Matchday","path":[[2,13],[2,12],[2,11],[2,10],[2,9],[2,8],[2,7],[2,6]]},
    {"text":"CUPGLORY","display_text":"Cup Glory","path":[[10,6],[11,6],[12,6],[13,6],[14,6],[15,6],[16,6],[17,6]]},
    {"text":"OLDBIGHEAD","display_text":"Old Big Head","path":[[7,4],[8,4],[9,4],[10,4],[11,4],[12,4],[13,4],[14,4],[15,4],[16,4]]},
    {"text":"TRICKYTREES","display_text":"Tricky Trees","path":[[14,15],[13,15],[12,15],[11,15],[10,15],[9,15],[8,15],[7,15],[6,15],[5,15],[4,15]]},
    {"text":"CHAMPS","display_text":"1979 Champs","path":[[1,9],[2,9],[3,9],[4,9],[5,9],[6,9]]},
    {"text":"MULLOFKINTYRE","display_text":"Mull of Kintyre","path":[[13,9],[14,9],[15,9],[16,9],[17,9],[18,9],[19,9],[20,9],[21,9],[22,9],[23,9],[24,9],[25,9]]}
  ],
  "settings": { "rows": 30, "cols": 20 }
};

// ====== Build grid ======
const rows = PUZZLE.settings.rows, cols = PUZZLE.settings.cols;
const gridStrings = PUZZLE.grid;
const answers = PUZZLE.words.map(w => ({ text:w.text, display:w.display_text||w.text, path:w.path.map(([r,c])=>[r,c]) }));

const gridEl = document.getElementById('grid');
const wordsList = document.getElementById('wordsList');
const timerEl = document.getElementById('timer');
const progressEl = document.getElementById('progress');
const resetBtn = document.getElementById('resetBtn');
const revealBtn = document.getElementById('revealBtn');

const grid=[]; const cellEls=[];
for(let r=0;r<rows;r++){
  grid[r]=[]; cellEls[r]=[]; const line=gridStrings[r]||"";
  for(let c=0;c<cols;c++){
    const ch=(line[c]||' ');
    grid[r][c]=ch;
    const el=document.createElement('div');
    el.className='cell'+(ch.trim()===''?' empty':'');
    el.dataset.r=r; el.dataset.c=c; el.textContent=ch.trim()===''?'':ch;
    gridEl.appendChild(el); cellEls[r][c]=el;
  }
}

const wordState=new Map(); answers.forEach(a=>wordState.set(a.text,{found:false}));

function renderWords(){
  // Sort: unfinished first, then finished; within each group preserve initial order
  const unfinished = answers.filter(a=>!wordState.get(a.text).found);
  const finished = answers.filter(a=>wordState.get(a.text).found);
  const ordered = [...unfinished, ...finished];
  wordsList.innerHTML='';
  ordered.forEach(a=>{
    const row=document.createElement('div'); row.className='word'+(wordState.get(a.text).found?' done':'');
    const l=document.createElement('div'); l.className='txt'; l.textContent=a.display;
    const ok=document.createElement('div'); ok.className='ok'; ok.textContent=wordState.get(a.text).found?'✓':'';
    row.append(l,ok);
    row.onclick=()=>{ const [r,c]=a.path[0]; const el=cellEls[r][c]; el.scrollIntoView({block:'center', inline:'center', behavior:'smooth'}); el.classList.add('hover'); setTimeout(()=>el.classList.remove('hover'),600); };
    wordsList.appendChild(row);
  });
}
renderWords();

function coordsEqual(a,b){return a[0]==b[0]&&a[1]==b[1];}
function pathEquals(p1,p2){ if(p1.length!==p2.length) return false; for(let i=0;i<p1.length;i++) if(!coordsEqual(p1[i],p2[i])) return false; return true; }
function reversePath(p){ return [...p].reverse(); }
function genLinePath(r0,c0,r1,c1){ let dr=r1-r0, dc=c1-c0; const steps=Math.max(Math.abs(dr),Math.abs(dc)); if(steps===0) return [[r0,c0]]; const stepR=dr===0?0:(dr/Math.abs(dr)); const stepC=dc===0?0:(dc/Math.abs(dc)); if(!((stepR===0||stepC===0)||(Math.abs(dr)===Math.abs(dc)))) return []; const path=[]; let r=r0,c=c0; for(let i=0;i<=steps;i++){ path.push([r,c]); r+=stepR; c+=stepC; } return path; }
let isDown=false,start=null,preview=new Set(),foundPaths=[];
function clearPreview(){ preview.forEach(k=>{ const [r,c]=k.split(',').map(Number); cellEls[r][c].classList.remove('preview','selected'); }); preview.clear(); }
function markFound(p){ foundPaths.push(p); p.forEach(([r,c])=>cellEls[r][c].classList.add('found')); }
function refreshProgress(){ const n=answers.filter(a=>wordState.get(a.text).found).length; progressEl.textContent=`${n} / ${answers.length}`; }
function tryCommit(r0,c0,r1,c1){ const sel=genLinePath(r0,c0,r1,c1); if(!sel.length) return false; for(const ans of answers){ if(wordState.get(ans.text).found) continue; if(pathEquals(sel,ans.path)||pathEquals(sel,reversePath(ans.path))){ wordState.get(ans.text).found=true; markFound(sel); renderWords(); refreshProgress(); checkWin(); return true; } } sel.forEach(([r,c])=>cellEls[r][c].classList.add('selected')); setTimeout(()=>sel.forEach(([r,c])=>cellEls[r][c].classList.remove('selected')),220); return false; }
function checkWin(){ if(answers.every(a=>wordState.get(a.text).found)){ const secs=Math.floor((Date.now()-startTime)/1000); const mm=String(Math.floor(secs/60)).padStart(2,'0'); const ss=String(secs%60).padStart(2,'0'); alert(`All done! Time: ${mm}:${ss}`); } }

function cellFromEvent(e){ if(e.touches&&e.touches.length){ const t=e.touches[0]; const el=document.elementFromPoint(t.clientX,t.clientY); if(!el||!el.classList.contains('cell')) return null; return [+el.dataset.r,+el.dataset.c]; } else { const el=e.target.closest('.cell'); if(!el) return null; return [+el.dataset.r,+el.dataset.c]; } }

const gridRoot=document.getElementById('grid');
const bind = (el, ev, fn, opts)=> el.addEventListener(ev, fn, opts||false);
bind(gridRoot,'mousedown', e=>{ const pos=cellFromEvent(e); if(!pos) return; const [r,c]=pos; if(grid[r][c].trim()==='') return; isDown=true; start=pos; clearPreview(); e.preventDefault(); });
bind(gridRoot,'mousemove', e=>{ if(!isDown) return; const pos=cellFromEvent(e); if(!pos) return; clearPreview(); const sel=genLinePath(start[0],start[1],pos[0],pos[1]); sel.forEach(([rr,cc])=>{ if(grid[rr][cc].trim()!==''){ const key=rr+','+cc; preview.add(key); cellEls[rr][cc].classList.add('preview'); } }); });
bind(window,'mouseup', e=>{ if(!isDown) return; const pos=cellFromEvent(e)||start; isDown=false; tryCommit(start[0],start[1],pos[0],pos[1]); clearPreview(); });
bind(gridRoot,'touchstart', e=>{ const pos=cellFromEvent(e); if(!pos) return; const [r,c]=pos; if(grid[r][c].trim()==='') return; isDown=true; start=pos; clearPreview(); }, {passive:true});
bind(gridRoot,'touchmove', e=>{ if(!isDown) return; const pos=cellFromEvent(e); if(!pos) return; clearPreview(); const sel=genLinePath(start[0],start[1],pos[0],pos[1]); sel.forEach(([rr,cc])=>{ if(grid[rr][cc].trim()!==''){ const key=rr+','+cc; preview.add(key); cellEls[rr][cc].classList.add('preview'); } }); }, {passive:true});
bind(window,'touchend', e=>{ if(!isDown) return; isDown=false; let end=start; if(preview.size){ const last=Array.from(preview).pop().split(',').map(Number); end=last; } tryCommit(start[0],start[1],end[0],end[1]); clearPreview(); }, {passive:true});

// Timer
let startTime=Date.now(); setInterval(()=>{ const secs=Math.floor((Date.now()-startTime)/1000); const mm=String(Math.floor(secs/60)).padStart(2,'0'); const ss=String(secs%60).padStart(2,'0'); timerEl.textContent = mm+':'+ss; }, 1000);

// Fit the grid within .grid-wrap
function computeFit(){
  const wrap = document.querySelector('.grid-wrap');
  const rect = wrap.getBoundingClientRect();
  const vw=innerWidth;
  const gap = vw<520 ? 1 : (vw<760 ? 2 : 4);
  document.documentElement.style.setProperty('--gap', gap+'px');
  const totalGapW=gap*(cols-1); const totalGapH=gap*(rows-1);
  const maxCellW=(rect.width-totalGapW)/cols; const maxCellH=(rect.height-totalGapH)/rows;
  let cell=Math.floor(Math.max(8, Math.min(maxCellW,maxCellH)));
  cell=Math.min(cell, 48);
  document.documentElement.style.setProperty('--cell', cell+'px');
}
let rAF=null; function scheduleFit(){ if(rAF) cancelAnimationFrame(rAF); rAF=requestAnimationFrame(()=>{ computeFit(); rAF=null; }); }
addEventListener('resize', scheduleFit); addEventListener('orientationchange', scheduleFit);
scheduleFit();
refreshProgress();

// Buttons
function resetGame(){ wordState.forEach(v=>{ v.found=false; }); for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) cellEls[r][c].classList.remove('found','preview','selected'); startTime = Date.now(); renderWords(); refreshProgress(); }
function revealOne(){ const remaining = answers.filter(a=>!wordState.get(a.text).found); if(!remaining.length) return; const a = remaining[Math.floor(Math.random()*remaining.length)]; wordState.get(a.text).found = true; markFound(a.path); renderWords(); refreshProgress(); }
resetBtn?.addEventListener('click', resetGame);
revealBtn?.addEventListener('click', revealOne);
</script>
</body>
</html>
